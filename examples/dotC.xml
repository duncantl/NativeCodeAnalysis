<section
	 xmlns:r="http://www.r-project.org"
	 xmlns:c="http://www.C.org">
<title><r:func>.C</r:func> Routines</title>

<para>
  Consider
<c:code>
void
bar(int *x, int *len, int *ans)
{
    for(int i = 0;  i < *len; i++)
	ans[i] = f(x[i]);
}
</c:code>  
It is clear that <c:var>ans</c:var> <c:var>x</c:var> have the same length.
How do we programmatically determine this?
We'll use a similar  approach to what we did for <r/> objects
in <r:func>.Call</r:func> routines.
That is, we find the places in the <c/> code where elements of each argument are
accessed. Then we determine the range of these indices and then compare them.
</para>
<para>
We'll start with the simple variable <c:var>len</c:var>.
<r:code>
library(Rllvm); library(NativeCodeAnalysis)
rw = parseIR("readWrite.ir")  
p = getParameters(rw$bar)  
</r:code>
<r:code>
getAllUsers(p$len)
<r:output><![CDATA[
[[1]]
[1] "  %0 = load i32, i32* %len, align 4, !tbaa !3"

[[2]]
[1] "  %2 = load i32, i32* %len, align 4, !tbaa !3"
]]></r:output>
</r:code>
These load the value of the parameter.
So it is clear it is not being treated as a pointer
whose elements will be accessed in future instructions.
We can check the uses of these load instructions:
<r:code>
lapply(getAllUsers(p$len), getAllUsers)
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %cmp7 = icmp sgt i32 %0, 0"


[[2]]
[[2]][[1]]
[1] "  %3 = sext i32 %2 to i64"
]]></r:output>  
</r:code>
Again both work on the value of the parameter and not on elements of a vector.
</para>
<para>
For the <c:var>x</c:var> parameter,
we have
<r:code>
getAllUsers(p$x)
<r:output><![CDATA[
[[1]]
[1] "  %arrayidx = getelementptr inbounds i32, i32* %x, i64 %indvars.iv"
]]></r:output>
</r:code>  
This is clearly accessing elements.
Given this, we can use 
</para>


<para>
We can determine which vectors have their elements modified
and are "intended"  to deliver the results from the routine:
<r:code>
sapply(getParameters(rw$bar), onlyReadsMemory)
<r:output><![CDATA[
    x   len   ans 
 TRUE  TRUE FALSE 
]]></r:output>
</r:code>
So this is just <c:var>ans</c:var> as we can easily determine directly.
</para>


<para>
For the parameter <c:var>x</c:var>, we have 
<r:code>
getAllUsers(p$x)
<r:output><![CDATA[
[[1]]
[1] "  %arrayidx = getelementptr inbounds i32, i32* %x, i64 %indvars.iv"
]]></r:output>
</r:code>
Similarly, for <c:var>ans</c:var>, we have
<r:code>
getAllUsers(p$ans)  
<r:output><![CDATA[
[[1]]
[1] "  %arrayidx2 = getelementptr inbounds i32, i32* %ans, i64 %indvars.iv"
]]></r:output>
</r:code>

<r:code>
u = getAllUsers(p$ans)[[1]]
findIndexRange(u)
</r:code>

</para>





<section>
<title></title>

<para>
Consider
<c:code>
void
foo(int *x, int *len)
{
    for(int i = 0;  i < *len; i++)
	x[i] = f(x[i]);
}
</c:code>
It is clear that we overwrite the values in <c:var>x</c:var>
and that is how we return the results.
We can programmatically determine this with
<r:code>
sapply(getParameters(rw$foo), onlyReadsMemory)
<r:output><![CDATA[
    x   len 
FALSE  TRUE 
]]></r:output>
</r:code>
</para>
</section>

</section>
