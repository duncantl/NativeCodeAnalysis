<section
	 xmlns:r="http://www.r-project.org"
	 xmlns:c="http://www.C.org"
	 xmlns:sh="http://www.shell.org"
         xmlns:cpre="http://www.preprocessor.org"	
	 xmlns:cpp="http://www.cplusplus.org"
	 xmlns:ir="http://llvm.org/ir">
<title><r/> Type Inference for <r:pkg>Rcpp</r:pkg> Code</title>

<para>
  In this document, we explore using the same basic approach as we do in <r:func>getRReturnTypes</r:func>
  but applied to <r:pkg>Rcpp</r:pkg> native code.
  This is potentially different   because a) it is <cpp/> code, b) it is templated,
  c) it uses <cpp/> exceptions to handle errors, 
  d) while built on the <r/> API, <r:pkg>Rcpp</r:pkg> uses its own syntactic sugar and idioms.
</para>

<para>
  The short summary is that the same basic approach works, but we have to deal with a few <cpp/> differences
  and utilize knowledge of a few <r:pkg>Rcpp</r:pkg> interface classes and methods, just as we did
  "hard code" for the <r/> API.  In other words, these are the primitives we need to identify manually but from which
  we can programmatically infer higher-level functionality and types.
</para>




<para>
The example code come from the rcppexamples package on github
<ulink url="https://github.com/eddelbuettel/rcppexamples.git"/>.
git clone them within this directory and the code should work.
You have to create the IR code for the <ext>cpp</ext> files , e.g.,
<sh:code>
clang -S -emit-llvm NumericVectorExample.cpp -fno-discard-value-names -O2 -o NumericVectorExample_priginal.ir -I` R RHOME`/include `Rscript -e 'Rcpp:::CxxFlags()'`  
</sh:code>
</para>



<para>
After experimenting (below), this is hopefully a general way to proceed.
We'll assume that the wrapper routines callable from R were generated by <r:func>Rcpp::compileAttributes</r:func>
to create a file <file>RcppExports.cpp</file> in the package's <dir>src</dir> directory.
Here we are working with the <r:pkg>RcppExamples</r:pkg> package.
<ol>  
<li> Parse the IR code for RcppExports.ir  (<r:expr>m3 = parseIR("rcppexamples/src/RcppExports02.ir")</r:expr>)</li>
<li> Find the names of the routines of interest in that  (<r:expr>v = grep("^_RcppExamples", getDefinedRoutines(m3), value = TRUE)</r:expr>)</li>
<li> We can also get the corresponding Function objects (<r:expr>m3[v]</r:expr>) and verify that all
are <r:func>.Call</r:func>-compatible
<r:code>
stopifnot(all(sapply(m3[v], function(f) sameType(getReturnType(f), SEXPType))))
stopifnot(all(sapply(m3[v], function(f) all(sapply(getParameters(f), function(p) sameType(getType(p), SEXPType))))))
</r:code>
</li>
<li>
 Focusing on <c:func>_RcppExamples_NumericVectorExample</c:func>, we find what routines it calls. (<r:expr>cfuns = getCalledFunctions(m3[[ "_RcppExamples_NumericVectorExample"]] )</r:expr>)
 We find 29 unique routines, some from the R API, some <cpp/> routines (e.g. __cxa_begin_catch, __clang_call_terminate,
 __cxa_guard_abort, operator delete(void*)), some <r:pkg>Rcpp</r:pkg> routines (e.g., exception_to_condition_template, Rcpp::RObject_Impl).
 We also see NumericVectorExample:
 <r:output><![CDATA[
"_Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE" # mangled name 
"NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)" # demangled name                                                                           
]]></r:output>
This is the call to the actual routine for which <c:func>_RcppExample_NumericVectorExample</c:func> is a wrapper.
From this demangled name, we have the type of the input argument - a numeric vector based on the number 14 in the
template corresponding to REALSXP. This comes from <c:type><![CDATA[Rcpp::Vector<14, Rcpp::PreserveStorage>]]></c:type>.
</li>

<li>
While we have the <r/> type of the parameter, we cannot tell the <r/> type of the return value.
The return type of <c:func>NumericVectorExample</c:func>   is <c:void/>.  Yet if we look at the <cpp/> code for the
wrapper routine, we have
<c:code>
rcpp_result_gen = Rcpp::wrap(NumericVectorExample(orig));
return rcpp_result_gen;
</c:code>
and it would appear the code directly uses the return value from <c:func>NumericVectorExample</c:func> in a call to
<c:func>Rcpp::wrap</c:func>.
However, the compiler is rearranging this call and the definition of the actual routine
<c:func>NumericVectorExample</c:func> to add a parameter that is used to return the result rather than returning it
directly.
This is because the <c:type>Rcpp::List</c:type> that <c:func>NumericVectorExample</c:func> returns is not a pointer but
a regular <cpp/> object,
like a struct and the compiler doesn't return regular objects on the stack, but via this additional parameter mechanism
for the return value. (We saw this in <r:pkg>RCIndex</r:pkg> and clang simple parsing where the callback routines
are passed the CXCursor structl instances by value.) Note however, that we don't see this additional parameter in its declaration in the
<file>RcppExports</file> module. It appears to have a single parameter, the numeric vector.
Similarly, the compiler handles marshalling this return value to and from the call to
<c:func>NumericVectorExample</c:func>
and passing it to the call to <c:func>Rcpp::wrap</c:func>.
So next, we will look at the <c:func>NativeVectorExample</c:func> routine.
</li>

<li>
We find the definition of the actual routine our wrapper calls <emdash>NumericVectorExample</emdash>  by looking through the modules generated from the <ir/> code
from the other files in the <dir>src</dir> directory:
<r:code><![CDATA[
src.modules = lapply(list.files("rcppexamples/src", pattern = "\\.ir", full.names = TRUE), parseIR)
w = sapply(src.modules, function(m) length(grep("^NumericVectorExample", demangle(getDefinedRoutines(m)), value = TRUE)) > 0)
m2 = src.modules[[which(w)]]
r = getDefinedRoutines(m2, names = FALSE)
fun = r[[ which(grepl("^NumericVectorExample", demangle(getDefinedRoutines(m2))))]]
]]>
<r:output><![CDATA[
void _Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE ( %"class.Rcpp::Vector.3.43"* agg.result, %"class.Rcpp::Vector.46"* orig )
]]></r:output>
</r:code>
This version of the routine appears to have 2 parameters and their types are generic <c:type>Rcpp::Vector</c:type> classes without information that identifies
which type of vector (logical, integer, numeric, etc.).  But we know that the first parameter is for the return value
and the second one (from examining the wrapper routine) is a <c:type>NumericVector</c:type> based on the demangled name
of the called routine in <file>RccExports</file>.
We could also see where this second parameter is used in this routine to determine if that provides supporting or contradictory evidence that
it is a numeric vector. However, we assume it is correct and that the declaration and definition agree across the two
<cpp/> files.
</li>
<li>
Finding the specific <r/> type of the return value.
From the signature of the routine, the return type is <c:type>void</c:type>.
We know the result is marshaled back to the caller via the first argument.
We see where in the routine that first argument is used (presumably set) by looking at all instructions that reference
it (<r:func>getAllUsers</r:func>):
<r:code>
p = getParameters(fun)
u = getAllUsers(p[[1]])
</r:code>
There is a single use and it is call to
<r:code>
k = u[[1]]
demangle(getName(getCalledFunction(k)))
<r:output><![CDATA[
Rcpp::Vector<19, Rcpp::PreserveStorage> // return type
Rcpp::Vector<19, Rcpp::PreserveStorage>::create__dispatch<Rcpp::traits::named_object<Rcpp::Vector<14,   Rcpp::PreserveStorage> >, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > >(
     Rcpp::traits::integral_constant<bool, true>,
     Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&,
     Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&)
]]></r:output>  
</r:code>
(where we have formatted the string to show the return type, the name of the routine (with the templates) and the 3 parameters.)
</li>
<li>
From the demangled name, we know the return value of this <c:func>create__dispatch</c:func> call is a list based on the value 19 in the
template type  corresponding to VECSXP, the list SEXPTYPE.
</li>
<li>
  From the call above, we see that the <c:func>create_dispatch</c:func> method is a member of the templated class,
  specialized for 19/list (  <r:class><![CDATA[Rcpp::Vector<19, ..>]]></r:class>), and that the
  method itself is templated for two traits::named_object inputs, each containing a
  <cpp:class><![CDATA[Rcpp::Vector<14,...>]]></cpp:class> vector. So again, based on a high-level understanding
  of <r:pkg>Rcpp</r:pkg>, we "know" that this is list
  with named elements and the elements are both numeric vectors.
</li>
<li>
From the call, we see that the first parameter of <c:func>NumericVectorExample</c:func> is the first argument in this call to
create__dispatch.
<r:code>
sapply(k[1:3], identical, p[[1]])
<r:output><![CDATA[
[1]  TRUE FALSE FALSE
]]></r:output>
</r:code>
</li>
<li>
<!-- 
named_object
  name is first element
  set that with basic_string.
  value comes from name.i.i.i
    value of first element of a Rcpp::Argument - one element, a string.
    where is this set?
 -->
  
The two additional arguments are <c:type>Rcpp::traits::named_object</c:type> values:
<r:code>
sapply(k[2:3],  function(x) getName(getElementType(getType(x))))
<r:output><![CDATA[
[1] "class.Rcpp::traits::named_object.49"
[2] "class.Rcpp::traits::named_object.49"
]]></r:output>
</r:code>
We want to find both the value and the name of each of these.
</li>
<li>
We'll process both arguments in the same way for this call that creates the List, but for now, we will focus on the second argument to describe the
steps. We want the name and the <r/> type of the value of this element.
We find the uses, other than the one in this call <r:var>k</r:var> that creates the list, and for each of these uses
we'll find the next immediate uses of them:
<r:code>
u2 = getAllUsers(k[[2]])
u2 = u2[!sapply(u2, identical, k)]
au2 = lapply(u2, function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %27 = bitcast %\"class.Rcpp::traits::named_object.49\"* %ref.tmp to i8*"

[[1]][[2]]
[1] "  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %27) #13"

[[1]][[3]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %27) #13"

[[1]][[4]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %27) #13"


[[2]]
[[2]][[1]]
[1] "  %30 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp, i64 0, i32 0"

[[2]][[2]]
[1] "  store %\"class.std::__1::basic_string.50\"* %name.i.i.i, %\"class.std::__1::basic_string.50\"** %30, align 8"


[[3]]
[[3]][[1]]
[1] "  %31 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp, i64 0, i32 1"

[[3]][[2]]
[1] "  store %\"class.Rcpp::Vector.46\"* %vec, %\"class.Rcpp::Vector.46\"** %31, align 8"
]]></r:output>
</r:code>
The first of these is memory bookkeeping and not of interest to us in finding the types and names of elements in <r/>
objects.
<para>
The second set of uses accesses the first field in the <c:type>Rcpp::traits:named_object</c:type> structure/class (via a
GEP instruction) and then assigns a value to it.
From the <ir/> code or querying the type definition in <r/>, we see the definition of this type is:
<ir:code>
%"class.Rcpp::traits::named_object" = type { %"class.std::__1::basic_string"*, %"class.Rcpp::Vector"* }
</ir:code>
So the first element is a <cpp/> string and is the name for the named object, and the second element is the associated <r/>
object (more precisely the <r:pkg>Rcpp</r:pkg> object representing this <r/> object.)
We want to find the value of the name to see if it is fixed/known at compile time.
We can follow the value for the name of this element by looking at what is being stored in <ir:var>%30</ir:var>, the name field in the
<r:class>traits::named_object</r:class> (which is <ir:var>%ref.tmp</ir:var>.) Specifically, we know the second instruction in this set of uses is setting the first
field of the named_object %ref.tmp to the value of %name.i.i.i.  So where is %name.i.i.i defined?
<r:code>
au2[[2]][[2]][[1]]
<r:output><![CDATA[
[1] "  %name.i.i.i = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0"
]]></r:output>
</r:code>
This is accessing the first field in an <c:type>Rcpp::Argument</c:type> object (again via a GEP.)
Again, from the IR or <r/> query, we can learn that the <c:type>Rcpp::Argument</c:type> has a single field which is a string.
So we want to find where this instance of the  <cpp:class>Rcpp::Argument</cpp:class> (%ref.tmp8) is defined and its field's value set so we can determine that value:
<r:code>
arg = au2[[2]][[2]][[1]][[1]]
c(arg, getAllUsers(arg ))
<r:output><![CDATA[
[[1]]
[1] "  %ref.tmp8 = alloca %\"class.Rcpp::Argument.56\", align 8"

[[2]]
[1] "  %28 = bitcast %\"class.Rcpp::Argument.56\"* %ref.tmp8 to i8*"

[[3]]
[1] "  %name.i.i.i = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0"

[[4]]
[1] "  %__data_.i.i.i.i.i91 = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 2"

[[5]]
[1] "  %__data_.i.i.i.i.i117 = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 2"
]]></r:output>
</r:code>
This <c:type>Rcpp::Argument</c:type> object is assigned to <ir:var>%ref.tmp8</ir:var>.
The last two users of this access the same element in the <cpp:class>Rcpp::Argument</cpp:class> structure and are deep/multi-level accessors.
</para>
<para>
It might be easier to look at the <r:class>BasicBlock</r:class>s in which the name is set
<ir:code>
entry:
  %vec = alloca %"class.Rcpp::Vector", align 8
  %ref.tmp = alloca %"class.Rcpp::traits::named_object", align 8
  %ref.tmp8 = alloca %"class.Rcpp::Argument", align 8
<codeEmphasis>  %ref.tmp9 = alloca %"class.std::__1::basic_string", align 8    </codeEmphasis>
  ...
</ir:code>
<ir:code>
invoke.cont6:                                     ; preds = %for.body.i, %middle.block, %invoke.cont4
  ...
<red>  %29 = bitcast %"class.std::__1::basic_string"* %ref.tmp9 to i8*</red>
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %29) #13
  store i8 12, i8* %29, align 8, !tbaa !24
<red> <![CDATA[ %__s.i.i.i.i = bitcast %"class.std::__1::basic_string"* %ref.tmp9 to %"struct.std::__1::basic_string<char>::__short"*]]></red>
<red> <![CDATA[ %arrayidx.i.i.i.i = getelementptr inbounds %"struct.std::__1::basic_string<char>::__short", %"struct.std::__1::basic_string<char>::__short"* %__s.i.i.i.i, i64 0, i32 1, i64 0]]></red>
<red>  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(6) %arrayidx.i.i.i.i, i8* nonnull align 1 dereferenceable(6) getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i64 6, i1 false) #13</red>
<![CDATA[  %arrayidx.i.i.i = getelementptr inbounds %"struct.std::__1::basic_string<char>::__short", %"struct.std::__1::basic_string<char>::__short"* %__s.i.i.i.i, i64 0, i32 1, i64 6
  store i8 0, i8* %arrayidx.i.i.i, align 1, !tbaa !24]]>
<red>  %name.i.i.i = getelementptr inbounds %"class.Rcpp::Argument", %"class.Rcpp::Argument"* %ref.tmp8, i64 0, i32 0</red>
<red>  invoke void @_ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_(%"class.std::__1::basic_string"* nonnull dereferenceable(24) %name.i.i.i, %"class.std::__1::basic_string"* nonnull align 8 dereferenceable(24) %ref.tmp9)
          to label %invoke.cont15 unwind label %lpad12</red>
</ir:code>
Heuristically, (following the highlighted code), the code is allocating a <c:type>std::string</c:type> variable to
<ir:var>%ref.tmp9</ir:var>, and then (in a different block) casts this to a memory address (i8*) yielding %29.
Next, the code stores the value 12 (an ASCII form feed character) in this address, then casts the %ref.tmp9 std::string to a
<cpp:class>basic_string</cpp:class> of <c:type>char</c:type>
elements (with "sub-type" short), assigning this to <ir:var>%__s.i.i.i.i</ir:var>.  Then we get the address of the 2nd
element (note the 3rd index) of this value which on my machine is a [23 x i8] array.  Then we call
<c:func>memcpy</c:func> to set the value of this array.  The second argument is
@.str  and this is the literal string value.
<r:code>
m2[[".str"]]
<r:output><![CDATA[
[1] "@.str = private unnamed_addr constant [7 x i8] c\"result\\00\", align 1"a
]]></r:output>
getValue(m2[[".str"]])
<r:output><![CDATA[
[1] "result"
]]></r:output>
</r:code>
</para>
<para>
  The final highlighted instruction uses this literal value to set <ir:var>name.i.i.i</ir:var>.
  Recall, this was the first element of the <cpp:class>Rcpp::Argument</cpp:class> object
  and is the value that is stored in the
  first element of our <cpp:class>Rcpp::traits::named_object</cpp:class> representing the first
  element of the List being returned.  So, somewhat indirectly, the name of the first element
  in this List is <literal>result</literal>.
</para>
<para>
  The indirect path to the value comes from the use of <r:pkg>Rcpp</r:pkg>  objects
  which contain a <cpp:class>std::basic_string</cpp:class>, and setting these and the contents of the
  basic string. In other words, there is quite a bit of 'boxing' involved, but it is a matter of dereferencing
  these carefully to get the ultimate value.
</para>
</li>
<li>
We now have the name for the first element of the list.
We next need to find the <r/> object for this element.
This appears to happen in the third set of users for the second argument, specifically
<r:output><![CDATA[
[1] "  %31 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp, i64 0, i32 1"
[1] "  store %\"class.Rcpp::Vector.46\"* %vec, %\"class.Rcpp::Vector.46\"** %31, align 8"
]]></r:output>
The first of these 2 instructions gets the memory address of the second element of the <ir:var>%ref.tmp</ir:var>, our
<c:type>Rcpp::traits::named_object</c:type> that is being used/set as the first element of our resulting list.
We saw that the <c:type>named_object</c:type> consists of the <cpp:class>std::basic_string</cpp:class> and the <r:pkg>Rcpp</r:pkg> object
representing the <r/>  object/value.  So this second element is the <r:pkg>Rcpp</r:pkg> object.
The second instruction stores <ir:var>%vec</ir:var> into this second element of the <c:type>named_object</c:type>.
So we are interested in the value being stored and look at <ir:var>vec</ir:var> and how it was created and modified:
<r:code>
v = au2[[3]][[2]][[1]]
<r:output><![CDATA[
[1] "  %vec = alloca %\"class.Rcpp::Vector.46\", align 8"
]]></r:output>
</r:code>
We see it is a generic <c:type>Rcpp::Vector</c:type> object, but this doesn't tell us what type of <r/> object it will contain.
There are two types of generic Rcpp::Vector in the <ir/> code - both with an <r/> preserve storage value, and
differing in the second field being a traits::r_vector_cache or a traits::proxy_cache object.
The particular type for <ir:var>vec</ir:var> has fields with types
<r:code>
sapply(getFields(getElementType(getType(v))), getName)
<r:output><![CDATA[
[1] "class.Rcpp::PreserveStorage.47"       
[2] "class.Rcpp::traits::r_vector_cache.48"
]]></r:output>
</r:code>

<para>
We are more interested in how <ir:var>%vec</ir:var> is manipulated and populated than how it is allocated, so we find
its uses:
<r:code>
getAllUsers(v)
<r:output><![CDATA[
[[1]]
[1] "  %0 = bitcast %\"class.Rcpp::Vector.46\"* %vec to i8*"

[[2]]
[1] "  %data.i.i.i = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 0, i32 0"

[[3]]
[1] "  %start.i.i.i.i = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 1, i32 0"

[[4]]
[1] "  %3 = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 0"

[[5]]
[1] "  store %\"class.Rcpp::Vector.46\"* %vec, %\"class.Rcpp::Vector.46\"** %31, align 8"
]]></r:output>  
</r:code>  
We are interested in how the first element of <ir:var>%vec</ir:var> is set as this is the <r/> object; the
r_vector_cache field is for attribute-like information(?).  The first element corresponds to accessing the GEP for 0, 0, 0, i.e.,
the second instruction in the use set. Similarly, the 4th instruction gets a reference to the first element of <ir:var>vec</ir:var>.
<fix>(Figure out why we need 3 levels)</fix>
For now, we focus on the 2nd instruction and we get all uses of the second instruction above:
<r:code>
a = getAllUsers(v)[[2]]
getAllUsers(a)
<r:output><![CDATA[
[[1]]
[1] "  store %struct.SEXPREC.41* %2, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[2]]
[1] "  %4 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[3]]
[1] "  %6 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[4]]
[1] "  %50 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[5]]
[1] "  %70 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"
]]></r:output>
</r:code>
We are not interested in when this loaded (at least for now), but where it is set, i.e., the first
instruction which is a store command.  We want the value which is being set:
<r:code>
getAllUsers(a)[[1]][[1]]
<r:output><![CDATA[
[1] "  %2 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** @R_NilValue, align 8, !tbaa !8"
]]></r:output>
</r:code>
So this just initializes the value to <r:null/>, not the real value in which we are interested.
</para>

<para>
We return to <r:var>v</r:var>, the instruction creating <ir:var>%vec</ir:var>, and look all the users of its users:
<r:code>
vu = lapply(getAllUsers(v), function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
...
[[4]][[1]]
[1] "  %3 = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 0"

[[4]][[2]]
[1] "  invoke void @_ZN4Rcpp15PreserveStorageINS_6VectorILi14ES0_EEE5set__EP7SEXPREC(%\"class.Rcpp::PreserveStorage.47\"* nonnull dereferenceable(8) %3, %struct.SEXPREC.41* %call.i.i)\n          to label %invoke.cont3.i.i unwind label %lpad.i.i"
...
]]></r:output>
</r:code>
We see that the first of these accesses the first element of <ir:var>%vec</ir:var>, and then uses that in a call to a routine:
<r:code>
demangle(getName(getCalledFunction(vu[[4]][[2]])))
<r:output><![CDATA[
[1] "Rcpp::PreserveStorage<Rcpp::Vector<14, Rcpp::PreserveStorage> >::set__(SEXPREC*)"  
]]></r:output>
</r:code>
So we know from the template information that the <r/> object is a numeric vector, i.e., with <c:type>SEXPTYPE</c:type> 14,
<cpre:define>REALSXP</cpre:define>.
The value in the call to set__ is a regular <c:type>SEXP</c:type>, an <r/>, not <r:pkg>Rcpp</r:pkg> object.
And we can examine the value to which it is being set (i.e., the second argument in the call to set__ after the implicit
<cpp:this/>) with
<r:code>
vu[[4]][[2]][[2]]
<r:output><![CDATA[
[1] "  %call.i.i = invoke %struct.SEXPREC.41* @Rf_allocVector(i32 14, i64 %call2.i)\n          to label %invoke.cont2.i.i unwind label %lpad.i.i"
]]></r:output>
</r:code>
again, confirming this is a numeric vector.
Importantly, we can examine the length of the vector from the second argument to this call to <c:func>Rf_allocVector</c:func>.
<r:code>
vu[[4]][[2]][[2]][[2]]
<r:output><![CDATA[
[1] "  %call2.i = tail call i64 @Rf_xlength(%struct.SEXPREC.41* %1)"
]]></r:output>
vu[[4]][[2]][[2]][[2]][[1]] # first argument of call to Rf_xlength
<r:output><![CDATA[
[1] "  %1 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i, align 8, !tbaa !3"
]]></r:output>
vu[[4]][[2]][[2]][[2]][[1]][[1]] # object being loaded
<r:output><![CDATA[
[1] "  %data.i.i = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %orig, i64 0, i32 0, i32 0"
]]></r:output>
vu[[4]][[2]][[2]][[2]][[1]][[1]][[1]]
<r:output><![CDATA[
[1] "%\"class.Rcpp::Vector.46\"* %orig"
]]></r:output>
</r:code>
And here we see that this is operating on the <r/> object that is in the input parameter <c:arg>orig</c:arg>.
So the length of this first element of the returned List has the same length as the parameter <c:arg>orig</c:arg>.
</para>

<para>
So we have the name, the type, and even the symbolic length of the first element of our list that is the result
of this routine.
</para>

</li>
<li>
  To strengthen our understanding of how to recover the name of the named objects
  and navigate the <cpp:class>std:string</cpp:class>, <cpp:class>Rcpp::Argument</cpp:class>, casting, memcpy, etc., we'll see how this is done
  for the second element (third element of <r:var>k</r:var>.)
  The <ir/> name of the third argument is <ir:var>%ref.tmp17</ir:var>:
<r:code>
getName(k[[3]])
</r:code>
This is not necessary for our analysis, but helps when reading it.


<para>
We start by getting all the users of the second element being inserted into the list:
<r:code>
au3 = lapply(getAllUsers(k[[3]]), function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %32 = bitcast %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17 to i8*"

[[1]][[2]]
[1] "  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %32) #13"

[[1]][[3]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %32) #13"

[[1]][[4]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %32) #13"


[[2]]
[[2]][[1]]
[1] "  %36 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17, i64 0, i32 0"

[[2]][[2]]
[1] "  store %\"class.std::__1::basic_string.50\"* %name.i.i.i81, %\"class.std::__1::basic_string.50\"** %36, align 8"


[[3]]
[[3]][[1]]
[1] "  %37 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17, i64 0, i32 1"

[[3]][[2]]
[1] "  store %\"class.Rcpp::Vector.46\"* %orig, %\"class.Rcpp::Vector.46\"** %37, align 8"


[[4]]
[[4]][[1]]
[1] "  invoke void @_ZN4Rcpp6VectorILi19ENS_15PreserveStorageEE16create__dispatchINS_6traits12named_objectINS0_ILi14ES1_EEEES7_EES2_NS4_17integral_constantIbLb1EEERKT_RKT0_(%\"class.Rcpp::Vector.3.43\"* sret(%\"class.Rcpp::Vector.3.43\") align 8 %agg.result, %\"class.Rcpp::traits::named_object.49\"* nonnull align 8 dereferenceable(16) %ref.tmp, %\"class.Rcpp::traits::named_object.49\"* nonnull align 8 dereferenceable(16) %ref.tmp17)\n          to label %invoke.cont27 unwind label %lpad24"

]]></r:output>
</r:code>  
We see a similar pattern to the uses as we did when analyzing the first element of the list.
We are interested in the second set of uses as this sets the first element of the named_object.
The first set of uses is bookkeeping, the third sets the <r:pkg>Rcpp</r:pkg>/<r/> object field and the fourth
is the creation  the list that we didn't omit.
</para>

<para>
In the second set of uses, the first instruction is the GEP for the name field (more specifically one level further?).
The second instruction sets that to <ir:var>%name.i.i.i81</ir:var>, so we follow this.
<r:code>
  au3[[2]][[2]][[1]]
<r:output><![CDATA[
[1] "  %name.i.i.i81 = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp18, i64 0, i32 0"
]]></r:output>  
</r:code>  
Again, we see this relates to an <c:type>Rcpp::Argument</c:type>.
We get all uses of this
<r:code>
z = getAllUsers(au3[[2]][[2]][[1]])
<r:output><![CDATA[
[[1]]
[1] "  invoke void @_ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_(%\"class.std::__1::basic_string.50\"* nonnull dereferenceable(24) %name.i.i.i81, %\"class.std::__1::basic_string.50\"* nonnull align 8 dereferenceable(24) %ref.tmp19)\n          to label %invoke.cont25 unwind label %lpad22"

[[2]]
[1] "  store %\"class.std::__1::basic_string.50\"* %name.i.i.i81, %\"class.std::__1::basic_string.50\"** %36, align 8"
]]></r:output>  
</r:code>
As we follow these chains, we get
<r:code>
getAllUsers(getAllUsers(getAllUsers(getAllUsers(z[[1]][[2]])[[2]])[[1]])[[1]])
<r:output><![CDATA[
[[1]]
[1] "  store i64 7809644627822735983, i64* %35, align 1"
]]></r:output>
</r:code>
</para>

<para>
  There appears to be something special about the word original.
  If we replace it with duncan, xyz, or riginal, we get literal values in the <ir/> code for these.
  If we replace it with Original (capital O), we don't get a literal value.
  If we change it priginal, we don't get a literal value.
</para>

</li>

<li>
<b>Finding the <r/> value and type of the second element of the list.</b>
The <r/> object for the second element of the list is relatively easy to determine using the same
initial approach we took for the first element of the list above.
<para>
We are interested in finding how this object is populated, specifically its first field
which holds the name of the object.
<r:code>
a3 = getAllUsers(k[[3]])
lapply(a3, function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
...
[[3]]
[[3]][[1]]
[1] "  %37 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17, i64 0, i32 1"

[[3]][[2]]
[1] "  store %\"class.Rcpp::Vector.46\"* %orig, %\"class.Rcpp::Vector.46\"** %37, align 8"

...
]]></r:output>
</r:code>
Again we see accessing the second field of the <c:type>Rcpp::Vector</c:type> (via a GEP) and then setting its value.
The value is the first element of the second instruction shown, specifically <ir:var>%orig</ir:var>.
And this is the second parameter to the routine, i.e., the input parameter that follows the artificial first parameter
created to marshal the return value.
<r:code>
identical(lapply(a3, function(x) c(x, getAllUsers(x)))[[3]][[2]][[1]], p[[2]])
<r:output><![CDATA[
[1] TRUE
]]></r:output>
</r:code>
So we know that the second element of the list is a <c:type>NumericVector</c:type>, and that it is actually
the original input value. Since that was marked as const, we know it didn't change.
(Do we know that it and it contents didn't change, including any element of the underlying <r/> vector, and the const
doesn't just apply to the <r:pkg>Rcpp</r:pkg> fields?)
</para>
</li>
</ol>
</para>






<para>
This example comes from <r:pkg>rcppexamples</r:pkg> and the file
<file>NumericVectorExample.cpp</file>
We generate the <ir/> for this code, using level 2 optimization:
<sh:code>
clang -S -emit-llvm -fno-discard-value-names NumericVectorExample.cpp -o NumericVectorExampleO2.ir  -I`R RHOME`/include -O2 `Rscript -e "Rcpp:::CxxFlags()"`  
</sh:code>
We read the <ir/> into <r/>
<r:code>
m2 = parseIR("src/rcppexamples/NumericVectorExampleO2.ir")
</r:code>
There are 106 elements in the module. We only care about the one we can invoke from <r/>.
The names are mangled. We know the name is NumericVectorExample so we can find it with
<r:code>
grep("NumericVectorExample", names(m2), value = TRUE)
<r:output><![CDATA[
[1] "_Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE"
[2] "_GLOBAL__sub_I_NumericVectorExample.cpp"                             
]]></r:output>
</r:code>
The demangled names are
<r:code>
demangle(grep("NumericVectorExample", names(m2), value = TRUE))
<r:output><![CDATA[
[1] "NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)"
[2] "_GLOBAL__sub_I_NumericVectorExample.cpp"                             
]]></r:output>
</r:code>
</para>


<para>
  In fact, we want to look at RcppExports.cpp first as this is the file that contain the <r/>-accessible routines
  generated by <r:pkg>Rcpp</r:pkg>.
<r:code>
m3 = parseIR("rcppexamples/src/RcppExports02.ir")
</r:code>
Again, this has many routines <emdash/> 107 defined in the module and others that are referenced.
<r:code>
defs = getDefinedRoutines(m3)
w = (defs == demangle(defs))
defs[w]
<r:output><![CDATA[
[1] "_RcppExamples_DataFrameExample"    
[2] "__clang_call_terminate"            
[3] "_RcppExamples_DateExample"         
[4] "_RcppExamples_ListExamples"        
[5] "_RcppExamples_MatrixExample"       
[6] "_RcppExamples_NumericVectorExample"
[7] "_RcppExamples_RcppRNGs"            
[8] "_RcppExamples_StringVectorExample" 
[9] "R_init_RcppExamples"               
]]></r:output>
</r:code>
So the routines with names starting with <literal>_RcppExamples</literal>
are the ones of interest.
We look at <r:expr eval="false">m3$"_RcppExamples_NumericVectorExample"</r:expr>
<r:output><![CDATA[
%struct.SEXPREC.124* _RcppExamples_NumericVectorExample ( %struct.SEXPREC.124* origSEXP )
]]></r:output>
So this takes a single <c:type>SEXP</c:type> value and returns a <c:type>SEXP</c:type> value.
</para>

<para>
This simple wrapper routine has 86 blocks:
<r:code>
r = m3$"_RcppExamples_NumericVectorExample"
length(getBlocks(r))
</r:code>
We can see the routines it calls with
<r:code>
unique(getCalledRoutines(r))
<r:output><![CDATA[
 [1] "__cxa_guard_acquire"                                                                                                                             
 [2] "Rf_install"                                                                                                                                      
 [3] "__cxa_guard_release"                                                                                                                             
 [4] "llvm.lifetime.start.p0i8"                                                                                                                        
 [5] "R_GetCCallable"                                                                                                                                  
 [6] "__cxa_guard_abort"                                                                                                                               
 [7] NA                                                                                                                                                
 [8] "Rcpp::Vector<14, Rcpp::PreserveStorage> Rcpp::internal::as<Rcpp::Vector<14, Rcpp::PreserveStorage> >(SEXPREC*, Rcpp::traits::r_type_generic_tag)"
 [9] "NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)"                                                                            
[10] "Rcpp::RObject_Impl<Rcpp::PreserveStorage>& Rcpp::RObject_Impl<Rcpp::PreserveStorage>::operator=<SEXPREC*>(SEXPREC* const&)"                      
[11] "R_ReleaseObject"                                                                                                                                 
[12] "__clang_call_terminate"                                                                                                                          
[13] "llvm.lifetime.end.p0i8"                                                                                                                          
[14] "llvm.eh.typeid.for"                                                                                                                              
[15] "__cxa_begin_catch"                                                                                                                               
[16] "__cxa_end_catch"                                                                                                                                 
[17] "Rf_onintr"                                                                                                                                       
[18] "Rcpp::exception::copy_stack_trace_to_r() const"                                                                                                  
[19] "SEXPREC* exception_to_condition_template<Rcpp::exception>(Rcpp::exception const&, bool)"                                                         
[20] "Rf_protect"                                                                                                                                      
[21] "SEXPREC* exception_to_condition_template<std::exception>(std::exception const&, bool)"                                                           
[22] "operator new(unsigned long)"                                                                                                                     
[23] "string_to_try_error(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)"                               
[24] "operator delete(void*)"                                                                                                                          
[25] "Rf_lang2"                                                                                                                                        
[26] "Rf_eval"                                                                                                                                         
[27] "Rf_inherits"                                                                                                                                     
[28] "TYPEOF"                                                                                                                                          
[29] "Rf_length"                                                                                                                                       
[30] "VECTOR_ELT"                                                                                                                                      
[31] "R_ContinueUnwind"                                                                                                                                
[32] "Rf_unprotect"                                                                                                                                    
]]></r:output>
</r:code>


</para>




<para>
Once we know we are calling the <c:func>NumericVectorExample</c:func>, we find it in the <ir/> code created from
<file>NumericVectorExample.cpp</file>.
<r:code>
m2 = parseIR("rcppexamples/src/NumericVectorExample02.ir")
r = getDefinedRoutines(m2, names = FALSE)
demangle(names(r))
f = r[[ grep("NumericVectorExample", names(r)) ]]
<r:output><![CDATA[
void _Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE ( %"class.Rcpp::Vector.3.266"* agg.result, %"class.Rcpp::Vector.269"* orig )
]]></r:output>
</r:code>
We can query the parameters and explore their types:
<r:code>
p =  getParameters(f)
a = p[[2]]
getType(a)
ty = getElementType(getType(a))
</r:code>
</para>

<para>
Curiously, if we get the names of the defined routines and demangle them, we get
<r:code>
demangle(getName(f))  
# or
demangle(getDefinedRoutines(m2))[[3]]
<r:output><![CDATA[
[3] "NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)"                                                                                                                                    ]]></r:output>
</r:code>
This shows the routine as having a single parameter, not two.
The first parameter in the actual <c:type>Function</c:type> object is used for returning the value of the routine.
</para>
<para>
Importantly, from this demangled name, we see the type of the input parameter (the second.)
It is <literal><![CDATA[Rcpp::Vector<14, Rcpp::PreserveStorage>]]></literal>.
The 14 is the <c:type>SEXPTYPE</c:type> and this corresponds to <cpre:define>REALSXP</cpre:define>.
This tells us the expected input type is a numeric vector.
We also see the object is constant, i.e., its contents are not changed.
</para>


<section>
<title>Additional Information from Parsing the <cpp/> Code</title>
<para>
<r:code>
library(RCIndex)
tu = createTU("~/GitWorkingArea/NativeCodeAnalysis/tests/rcppexamples/src/NumericVectorExample.cpp", gsub("^-I", "", capture.output(Rcpp:::CxxFlags())))
rc = getRoutines(tu)
</r:code>
<r:code>
nv = rc[["NumericVectorExample"]]
<r:output><![CDATA[
[1] "Rcpp::List NumericVectorExample(const NumericVector & orig)"
]]></r:output>
</r:code>

<r:code>
ty = getType(nv@params[[1]])
getName(ty)
<r:output><![CDATA[
[1] "const Rcpp::NumericVector &"
]]></r:output>
</r:code>
</para>
</section>


<section>
<title>Return Type</title>

<para>
  Using <llvm/>, the return type of the <c:func>NumericVectorExample</c:func> routine is
  <c:type>void</c:type>.
  The return value is set in the first argument and marshalled back to the caller via that.
  So we find where this first argument is used in the body of the routine
<r:code>
u = getAllUsers(p[[1]])
</r:code>
There is only one use of this argument in the NumericVectorExample routine.
This is an <r:class>InvokeInst</r:class> instruction. The routine that is called is
<r:code>
fun = getCalledFunction(u[[1]])
</r:code>
<ignore>
<note>We should be able to call getName(fun) to get the name and then demangle this. But we don't have a getName method
for a Function. (Added now.)
However, we can get the name with
<r:code><![CDATA[
i = which(sapply(getDefinedRoutines(as(fun, "Module"), names = FALSE), identical, u))
demangle(getDefinedRoutines(as(fun, "Module"))[i])
[1] "Rcpp::Vector<19, Rcpp::PreserveStorage> Rcpp::Vector<19, Rcpp::PreserveStorage>::create__dispatch<Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> >, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > >(Rcpp::traits::integral_constant<bool, true>, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&)"
]]></r:code>
</note>
</ignore>
</para>
</section>


<section>
<title>DateExample</title>

<para>
We look at the DateExample  :
<r:code>
mm = parseIR("rcppexamples/src/DateExample.ir")
r = getDefinedRoutines(mm, names = FALSE)
i = grep("DateExample", names(r))
f = r[[i]]
demangle(getName(f))
<r:output><![CDATA[
[1] "DateExample(Rcpp::newDateVector&, Rcpp::newDatetimeVector&)"
]]></r:output>
</r:code>
So we know the R types of the two parameters of DateExample.
</para>


<para>
Looking at the wrapper routines:  
<r:code>
m3 = parseIR("rcppexamples/src/RcppExports02.ir")
i = names(m3)[ grep("^_RcppExamples_", names(m3)) ] 
fun = m3[[ i[2] ]]
demangle(unique(getCalledFunctions(m3[[ i[2] ]])))
</r:code>
So we see the call to DateExample and also calls to <c:func><![CDATA[Rcpp:internal::as<> ]]></c:func> to create the
<c:type>Rcpp::newDateVector</c:type> and <c:type>Rcpp::newDatetimeVector</c:type> objects.
</para>



</section>


<section>
<title>Non-List Return Types</title>

<para>
<r:code>
eg  = parseIR("RcppEgO2.ir")
i = grep("row_max", names(eg), value = TRUE)
fun = eg[[i]]
demangle(getName(fun))
</r:code>
So we have the type of the sole parameter - a numeric Matrix.
</para>

<para>
The return value is again marshaled via a compiler-created first parameter.
We can find out where it is used in the routine:
<r:code>
u1 = getAllUsers(getParameters(fun)[[1]])
<r:output><![CDATA[
[[1]]
[1] "  %9 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0, i32 0"

[[2]]
[1] "  %11 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 1, i32 0"

[[3]]
[1] "  %15 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0"
]]></r:output>
</r:code>
These are GEP to access the first and second elements of the Rcpp::Vector object.
These may be used to read the value or to set the value.
We can follow these to see where they are used:
<r:code>
u2 = lapply(u1, function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %9 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0, i32 0"

[[1]][[2]]
[1] "  store %struct.SEXPREC.386* %10, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[3]]
[1] "  %17 = load %struct.SEXPREC.386*, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[4]]
[1] "  %33 = load %struct.SEXPREC.386*, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[5]]
[1] "  store %struct.SEXPREC.386* %43, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[6]]
[1] "  %78 = load %struct.SEXPREC.386*, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[7]]
[1] "  store %struct.SEXPREC.386* %88, %struct.SEXPREC.386** %9, align 8, !tbaa !10"


[[2]]
[[2]][[1]]
[1] "  %11 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 1, i32 0"

[[2]][[2]]
[1] "  store double* null, double** %11, align 8, !tbaa !12"

[[2]][[3]]
[1] "  %68 = load double*, double** %11, align 8, !tbaa !12"


[[3]]
[[3]][[1]]
[1] "  %15 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0"

[[3]][[2]]
[1] "  invoke void @_ZN4Rcpp15PreserveStorageINS_6VectorILi14ES0_EEE5set__EP7SEXPREC(%\"class.Rcpp::PreserveStorage.397\"* nonnull dereferenceable(8) %15, %struct.SEXPREC.386* %13)\n          to label %16 unwind label %31"
]]></r:output>
</r:code>
</para>

<para>
It is not obvious we should look at the third of these, but this accesses the first field which is the PreserveStorage
field of the Rcpp::Vector and then passes this to the routine
<r:code>
demangle(getName(getCalledFunction(u2[[3]][[2]])))
<r:output><![CDATA[
[1] "Rcpp::PreserveStorage<Rcpp::Vector<14, Rcpp::PreserveStorage> >::set__(SEXPREC*)"
]]></r:output>
</r:code>
This templated routine indicates that the <r/> object is a numeric vector.
The second arugment in this call to set__ is
<r:code>
u2[[3]][[2]][[2]]
<r:output><![CDATA[
[1] "  %13 = invoke %struct.SEXPREC.386* @Rf_allocVector(i32 14, i64 %12)\n          to label %14 unwind label %31"
]]></r:output>
</r:code>
and this is the value being set.
So we know that the return value's PreserveStorage field is being set to a numeric vector.
</para>
<para>
We can follow the second argument in the call to <c:func>Rf_allocVector</c:func> to
attempt to identify the length of the vector.
<r:code>
u2[[3]][[2]][[2]][[2]][[1]][[1]]
<r:output><![CDATA[
[1] "  %7 = getelementptr inbounds %\"class.Rcpp::Matrix.399\", %\"class.Rcpp::Matrix.399\"* %1, i64 0, i32 1"
]]></r:output>
</r:code>
And if we look at the type of the Rcpp::Matrix
<r:code>
getFields(getElementType(getType(u2[[3]][[2]][[2]][[2]][[1]][[1]][[1]])))
<r:output><![CDATA[
[[1]]
Type StructTyID 

[[2]]
Type IntegerTyID 

[[3]]
Type ArrayTyID 

]]></r:output>  
</r:code>
This second element (indexed as position 1 in the GEP) appears to be the number of rows in the matrix, and indeed is
when we look at Rcpp/vector/Matrix.h.
</para>




</section>




<section>
<title>Parsing the Template Parameter Types</title>

<para>
  We can write the routine signature to a file, preceded by an inclusion of Rcpp.h
  and adding the void return type for the routine.
Then we can use <r:pkg>RCIndex</r:pkg> to parse the <cpp/> code:
<r:code>
e = createTU("/tmp/foo.cc", "/Users/duncan/Rpackages4/Rcpp/include")
r = getRoutines(e)
</r:code>
For some reason, the parameter is a ParamDecl but does not have content.
</para>
</section>






</section>
