<section
	 xmlns:ir="http://llvm.org/ir"
	 xmlns:r="http://www.r-project.org"
	 xmlns:c="http://www.C.org"
	 xmlns:sh="http://www.shell.org">
<title></title>


<para>
The example code come from the rcppexamples package on github
<ulink url="https://github.com/eddelbuettel/rcppexamples.git"/>.
git clone them within this directory and the code should work.
You have to create the IR code for the <ext>cpp</ext> files , e.g.,
<sh:code>
clang -S -emit-llvm NumericVectorExample.cpp -fno-discard-value-names -O2 -o NumericVectorExample_priginal.ir -I` R RHOME`/include `Rscript -e 'Rcpp:::CxxFlags()'`  
</sh:code>
</para>



<para>
After experimenting (below), this is hopefully a general way to proceed.
We'll assume that the wrapper routines callable from R were generated by <r:func>Rcpp::compileAttributes</r:func>
to create a file <file>RcppExports.cpp</file> in the package's <dir>src</dir> directory.
Here we are working with the <r:pkg>RcppExamples</r:pkg> package.
<ol>  
<li> Parse the IR code for RcppExports.ir  (<r:expr>m3 = parseIR("rcppexamples/src/RcppExports02.ir")</r:expr>)</li>
<li> Find the names of the routines of interest in that  (<r:expr>v = grep("^_RcppExamples", getDefinedRoutines(m3), value = TRUE)</r:expr>)</li>
<li> We can also get the corresponding Function objects (<r:expr>m3[v]</r:expr>) and verify that all
are <r:func>.Call</r:func>-compatible
<r:code>
stopifnot(all(sapply(m3[v], function(f) sameType(getReturnType(f), SEXPType))))
stopifnot(all(sapply(m3[v], function(f) all(sapply(getParameters(f), function(p) sameType(getType(p), SEXPType))))))
</r:code>
</li>
<li>
 Focusing on <c:func>_RcppExamples_NumericVectorExample</c:func>, we find what routines it calls. (<r:expr>cfuns = getCalledFunctions(m3[[ "_RcppExamples_NumericVectorExample"]] )</r:expr>)
 We find 29 unique routines, some from the R API, some <cpp/> routines (e.g. __cxa_begin_catch, __clang_call_terminate,
 __cxa_guard_abort, operator delete(void*)), some <r:pkg>Rcpp</r:pkg> routines (e.g., exception_to_condition_template, Rcpp::RObject_Impl).
 We also see NumericVectorExample:
 <r:output><![CDATA[
"_Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE" # mangled name 
"NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)" # demangled name                                                                           
]]></r:output>
This is the call to the actual routine for which <c:func>_RcppExample_NumericVectorExample</c:func> is a wrapper.
From this demangled name, we have the type of the input argument - a numeric vector based on the number 14 in the
template corresponding to REALSXP. This comes from <c:type><![CDATA[Rcpp::Vector<14, Rcpp::PreserveStorage>]]></c:type>.
</li>

<li>
While we have the <r/> type of the parameter, we cannot tell the <r/> type of the return value.
The return type of <c:func>NumericVectorExample</c:func>   is <c:void/>.  Yet if we look at the <cpp/> code for the
wrapper routine, we have
<c:code>
rcpp_result_gen = Rcpp::wrap(NumericVectorExample(orig));
return rcpp_result_gen;
</c:code>
and it would appear the code directly uses the return value from <c:func>NumericVectorExample</c:func> in a call to
<c:func>Rcpp::wrap</c:func>.
However, I suspect that the compiler is rearranging this call and the definition of the actual routine
<c:func>NumericVectorExample</c:func> to add a parameter that is used to return the result rather than returning it
directly.
This is because the <c:type>Rcpp::List</c:type> that <c:func>NumericVectorExample</c:func> returns is a regular object,
like a struct and the compiler doesn't return regular objects on the stack, but via this additional parameter mechanism
for the return value. Note however, that we don't see this additional parameter in its declaration in the
<file>RcppExports</file> module. It appears to have a single parameter, the numeric vector.
So next, we will look at the <c:func>NativeVectorExample</c:func> routine.
</li>

<li>
We find the definition of the actual routine our wrapper calls <emdash>NumericVectorExample</emdash>  by looking through the modules generated from the <ir/> code
from the other files in the <dir>src</dir> directory:
<r:code><![CDATA[
src.modules = lapply(list.files("rcppexamples/src", pattern = "\\.ir", full.names = TRUE), parseIR)
w = sapply(src.modules, function(m) length(grep("^NumericVectorExample", demangle(getDefinedRoutines(m)), value = TRUE)) > 0)
m2 = src.modules[[which(w)]]
r = getDefinedRoutines(m2, names = FALSE)
fun = r[[ which(grepl("^NumericVectorExample", demangle(getDefinedRoutines(m2))))]]
]]>
<r:output><![CDATA[
void _Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE ( %"class.Rcpp::Vector.3.43"* agg.result, %"class.Rcpp::Vector.46"* orig )
]]></r:output>
</r:code>
This version of the routine appears to have 2 parameters and their types are generic <c:type>Rcpp::Vector</c:type> classes without information that identifies
which type of vector (logical, integer, numeric, etc.).  But we know the first parameter is for the return value
and the second one is a <c:type>NumericVector</c:type> based on the demangled name in <file>RccExports</file>.
We could also see where this second parameter is used in this routine to determine if that provide supporting or contradictory evidence that
it is a numeric vector. However, we assume it is correct and that the declaration and definition agree across the two
<cpp/> files.
</li>
<li>
Finding the <r/> type of the return value.
From the signature of the routine, the return type is <c:type>void</c:type>.
We know the result is marshaled back to the caller via the first argument.
We see where in the routine that first argument is used (presumably set) by looking at all instructions that reference
it (<r:func>getAllUsers</r:func>):
<r:code>
p = getParameters(fun)
u = getAllUsers(p[[1]])
</r:code>
There is a single use and it is call to
<r:code>
k = u[[1]]
demangle(getName(getCalledFunction(k)))
<r:output><![CDATA[
Rcpp::Vector<19, Rcpp::PreserveStorage>
Rcpp::Vector<19, Rcpp::PreserveStorage>::create__dispatch<Rcpp::traits::named_object<Rcpp::Vector<14,   Rcpp::PreserveStorage> >, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > >(
     Rcpp::traits::integral_constant<bool, true>,
     Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&,
     Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&)
]]></r:output>  
</r:code>
(where we have formatted the string to show the return type, the name of the routine (with the templates) and the 3 parameters.)
</li>
<li>
From the demangled name, we know the return value of this create__dispatch call is a list based on the value 19 in the
template type  corresponding to VECSXP, the list SEXPTYPE.
</li>
<li>
From the call, we see that the first parameter of <c:func>NumericVectorExample</c:func> is the first argument in this call to
create__dispatch.
<r:code>
sapply(k[1:3], identical, p[[1]])
<r:output><![CDATA[
[1]  TRUE FALSE FALSE
]]></r:output>
</r:code>
</li>
<li>
The two additional arguments are <c:type>Rcpp::traits::named_object</c:type> values:
<r:code>
sapply(k[2:3],  function(x) getName(getElementType(getType(x))))
<r:output><![CDATA[
[1] "class.Rcpp::traits::named_object.49"
[2] "class.Rcpp::traits::named_object.49"
]]></r:output>
</r:code>
We want to find both the value and the name of each of these.
</li>
<li>
We'll process both arguments in the same way for this call to create the List, but for now, we will focus on the second argument to describe the
steps. We want the name and the <r/> type of the value of this element.
We find the uses, other than the one in this call <r:var>k</r:var> that creates the list, and for each of these uses
we'll find the next immediate uses of them:
<r:code>
u2 = getAllUsers(k[[2]])
u2 = u2[!sapply(u2, identical, k)]
au2 = lapply(u2, function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %27 = bitcast %\"class.Rcpp::traits::named_object.49\"* %ref.tmp to i8*"

[[1]][[2]]
[1] "  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %27) #13"

[[1]][[3]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %27) #13"

[[1]][[4]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %27) #13"


[[2]]
[[2]][[1]]
[1] "  %30 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp, i64 0, i32 0"

[[2]][[2]]
[1] "  store %\"class.std::__1::basic_string.50\"* %name.i.i.i, %\"class.std::__1::basic_string.50\"** %30, align 8"


[[3]]
[[3]][[1]]
[1] "  %31 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp, i64 0, i32 1"

[[3]][[2]]
[1] "  store %\"class.Rcpp::Vector.46\"* %vec, %\"class.Rcpp::Vector.46\"** %31, align 8"
]]></r:output>
</r:code>
The first of these is memory bookkeeping and not of interest to us in finding the types and names of elements in <r/>
objects.
The second set of uses accesses the first field in the <c:type>Rcpp::traits:named_object</c:type> structure/class.
From the <ir/> code or querying the type definition in <r/>, we see the definition of this type is:
<ir:code>
%"class.Rcpp::traits::named_object" = type { %"class.std::__1::basic_string"*, %"class.Rcpp::Vector"* }
</ir:code>
So the first element is a string and is the name for the named object, and the second element is the associated <r/>
object (more precisely the <r:pkg>Rcpp</r:pkg> object representing this <r/> object.)
We want to find the value of the name to see if it is fixed/known at compile time.
We can follow the value for the name of this element by looking at what is being stored in %30, the name field in the
named_object which is %ref.tmp. Specifically, we know the second instruction in this set of uses is setting the first
field of the named_object to the value of %name.i.i.i.  So where is that defined
<r:code>
au2[[2]][[2]][[1]]
<r:output><![CDATA[
[1] "  %name.i.i.i = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0"
]]></r:output>
</r:code>
This is accessing the first field in an <c:type>Rcpp::Argument</c:type> object.
Again, from the IR or <r/> query, we can learn that the <c:type>Rcpp::Argument</c:type> has a single field which is a string.
So we want to find where that Rcpp::Argument is defined and its field's value set so we can determine that value:
<r:code>
arg = au2[[2]][[2]][[1]][[1]]
c(arg, getAllUsers(arg ))
<r:output><![CDATA[
[[1]]
[1] "  %ref.tmp8 = alloca %\"class.Rcpp::Argument.56\", align 8"

[[2]]
[1] "  %28 = bitcast %\"class.Rcpp::Argument.56\"* %ref.tmp8 to i8*"

[[3]]
[1] "  %name.i.i.i = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0"

[[4]]
[1] "  %__data_.i.i.i.i.i91 = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 2"

[[5]]
[1] "  %__data_.i.i.i.i.i117 = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp8, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 2"
]]></r:output>
</r:code>
This <c:type>Rcpp::Argument</c:type> object is assigned to %ref.tmp8.
The last two users of this access the same element in the Argument structure and are deep/multi-level acessors.
<para>
It might be easier to look at the <r:class>BasicBlock</r:class>s in which the name is set
<ir:code>
entry:
  %vec = alloca %"class.Rcpp::Vector", align 8
  %ref.tmp = alloca %"class.Rcpp::traits::named_object", align 8
  %ref.tmp8 = alloca %"class.Rcpp::Argument", align 8
<codeEmphasis>  %ref.tmp9 = alloca %"class.std::__1::basic_string", align 8    </codeEmphasis>
  ...
</ir:code>
<ir:code>
invoke.cont6:                                     ; preds = %for.body.i, %middle.block, %invoke.cont4
  ...
<red>  %29 = bitcast %"class.std::__1::basic_string"* %ref.tmp9 to i8*</red>
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %29) #13
  store i8 12, i8* %29, align 8, !tbaa !24
<red> <![CDATA[ %__s.i.i.i.i = bitcast %"class.std::__1::basic_string"* %ref.tmp9 to %"struct.std::__1::basic_string<char>::__short"*]]></red>
<red> <![CDATA[ %arrayidx.i.i.i.i = getelementptr inbounds %"struct.std::__1::basic_string<char>::__short", %"struct.std::__1::basic_string<char>::__short"* %__s.i.i.i.i, i64 0, i32 1, i64 0]]></red>
<red>  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(6) %arrayidx.i.i.i.i, i8* nonnull align 1 dereferenceable(6) getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i64 6, i1 false) #13</red>
<![CDATA[  %arrayidx.i.i.i = getelementptr inbounds %"struct.std::__1::basic_string<char>::__short", %"struct.std::__1::basic_string<char>::__short"* %__s.i.i.i.i, i64 0, i32 1, i64 6
  store i8 0, i8* %arrayidx.i.i.i, align 1, !tbaa !24]]>
<red>  %name.i.i.i = getelementptr inbounds %"class.Rcpp::Argument", %"class.Rcpp::Argument"* %ref.tmp8, i64 0, i32 0</red>
<red>  invoke void @_ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_(%"class.std::__1::basic_string"* nonnull dereferenceable(24) %name.i.i.i, %"class.std::__1::basic_string"* nonnull align 8 dereferenceable(24) %ref.tmp9)
          to label %invoke.cont15 unwind label %lpad12</red>
</ir:code>
Heuristically, (following the highlighted code), the code is allocating a <c:type>std::string</c:type> variable to
%ref.tmp9, and then (in a different block) casts this to a memory address (i8*) yielding %29.
Next, the code stores the value 12 in this address, then casts the %ref.tmp9 std::string to a basic string of char elements of type
short, assigning this to %__s.i.i.i.i.  Then we get the address of the 2nd element (note the 3rd index) of this value and then call <c:func>memcpy</c:func>.  The second argument is
@.str  and this is the literal string value.
<r:code>
m2[[".str"]]
<r:output><![CDATA[
[1] "@.str = private unnamed_addr constant [7 x i8] c\"result\\00\", align 1"a
]]></r:output>
getValue(m2[[".str"]])
<r:output><![CDATA[
[1] "result"
]]></r:output>
</r:code>
</para>
</li>
<li>
We have the name for the first element of the list.
We next need to find the <r/> object for this element.
This appears to happen in the third set of users for the second argument, specifically
<r:output><![CDATA[
[1] "  %31 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp, i64 0, i32 1"
[1] "  store %\"class.Rcpp::Vector.46\"* %vec, %\"class.Rcpp::Vector.46\"** %31, align 8"
]]></r:output>
The first of these gets the memory address of the second element of the %ref.tmp, our
<c:type>Rcpp::traits::named_object</c:type> that is being used/set as the first element of our resulting list.
We saw that the <c:type>named_object</c:type> consists of the std::basic_string and the <r:pkg>Rcpp</r:pkg> object
representing the <r/>  object/value.  So this second element is the <r:pkg>Rcpp</r:pkg> object.
The second instruction stores %vec into this second element of the <c:type>named_object</c:type>.
So we look at it and how it was created and modified.
<r:code>
v = au2[[3]][[2]][[1]]
<r:output><![CDATA[
[1] "  %vec = alloca %\"class.Rcpp::Vector.46\", align 8"
]]></r:output>
</r:code>
We see it is a generic <c:type>Rcpp::Vector</c:type> object, but this doesn't tell us what type of <r/> object it will contain.
There are two types of generic Rcpp::Vector in the <ir/> code:
<r:code>
sapply(getFields(getElementType(getType(v))), getName)
<r:output><![CDATA[
[1] "class.Rcpp::PreserveStorage.47"       
[2] "class.Rcpp::traits::r_vector_cache.48"
]]></r:output>
</r:code>
(The other type has a traits::proxy_cache object as the second field.)

<para>
  We find the uses of %vec:
<r:code>
getAllUsers(v)
<r:output><![CDATA[
[[1]]
[1] "  %0 = bitcast %\"class.Rcpp::Vector.46\"* %vec to i8*"

[[2]]
[1] "  %data.i.i.i = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 0, i32 0"

[[3]]
[1] "  %start.i.i.i.i = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 1, i32 0"

[[4]]
[1] "  %3 = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 0"

[[5]]
[1] "  store %\"class.Rcpp::Vector.46\"* %vec, %\"class.Rcpp::Vector.46\"** %31, align 8"
]]></r:output>  
</r:code>  
We are interested in how the first element of %vec is set. This corresponds to accessing the GEP for 0, 0, 0, i.e.,
the second use.
<fix>(Figure out why we need 3 levels)</fix>
So we get all uses of the second instruction above:
<r:code>
a = getAllUsers(v)[[2]]
getAllUsers(a)
<r:output><![CDATA[
[[1]]
[1] "  store %struct.SEXPREC.41* %2, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[2]]
[1] "  %4 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[3]]
[1] "  %6 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[4]]
[1] "  %50 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"

[[5]]
[1] "  %70 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i.i, align 8, !tbaa !3"
]]></r:output>
</r:code>
We are not interested in when this loaded (at least for now), but where it is set, i.e., the first
instruction which is a store command.  We want the value which is being set:
<r:code>
getAllUsers(a)[[1]][[1]]
<r:output><![CDATA[
[1] "  %2 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** @R_NilValue, align 8, !tbaa !8"
]]></r:output>
</r:code>
So this just initializes the value to <r:null/>, not the real value in which we are interested.
</para>

<para>
We return to <r:var>v</r:var>, the instruction creating %vec, and look all the users of its users:
<r:code>
vu = lapply(getAllUsers(v), function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
...
[[4]][[1]]
[1] "  %3 = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %vec, i64 0, i32 0"

[[4]][[2]]
[1] "  invoke void @_ZN4Rcpp15PreserveStorageINS_6VectorILi14ES0_EEE5set__EP7SEXPREC(%\"class.Rcpp::PreserveStorage.47\"* nonnull dereferenceable(8) %3, %struct.SEXPREC.41* %call.i.i)\n          to label %invoke.cont3.i.i unwind label %lpad.i.i"
...
]]></r:output>
</r:code>
We see access the first element of %vec, and then using that in a call to a routine:
<r:code>
demangle(getName(getCalledFunction(vu[[4]][[2]])))
<r:output><![CDATA[
[1] "Rcpp::PreserveStorage<Rcpp::Vector<14, Rcpp::PreserveStorage> >::set__(SEXPREC*)"  
]]></r:output>
</r:code>
So we know that the <r/> object is a numeric vector, i.e., with SEXPTYPE 14.
And we can examine the value to which it is being set with
<r:code>
vu[[4]][[2]][[2]]
<r:output><![CDATA[
[1] "  %call.i.i = invoke %struct.SEXPREC.41* @Rf_allocVector(i32 14, i64 %call2.i)\n          to label %invoke.cont2.i.i unwind label %lpad.i.i"
]]></r:output>
</r:code>
again, confirming this is a numeric vector.
Importantly, we can examine the length of the vector from the second argument to this call to <c:func>Rf_allocVector</c:func>.
<r:code>
vu[[4]][[2]][[2]][[2]]
<r:output><![CDATA[
[1] "  %call2.i = tail call i64 @Rf_xlength(%struct.SEXPREC.41* %1)"
]]></r:output>
vu[[4]][[2]][[2]][[2]][[1]][[2]] # first argument of call to Rf_xlength
<r:output><![CDATA[
[1] "  %1 = load %struct.SEXPREC.41*, %struct.SEXPREC.41** %data.i.i, align 8, !tbaa !3"
]]></r:output>
vu[[4]][[2]][[2]][[2]][[1]][[1]] # object being loaded
<r:output><![CDATA[
[1] "  %data.i.i = getelementptr inbounds %\"class.Rcpp::Vector.46\", %\"class.Rcpp::Vector.46\"* %orig, i64 0, i32 0, i32 0"
]]></r:output>
</r:code>
And here we see that this is operating on the <r/> object in the input parameter orig.
</para>


<para>
  So we have the name, the type, and even the symbolic length of the first element of our list that is the result
  of this routine.
</para>

</li>
<li>
  To strengthen our understanding of how to recover the name of the named objects
  and navigate the std:string, Rcpp::Argument, casting, memcpy, etc., we'll see how this is done
  for the second element (third element of <r:var>k</r:var>.)
  The <ir/> name of the third argument is %ref.tmp17:
<r:code>
getName(k[[3]])
</r:code>
This is not necessary for our analysis, but helps when reading it.


<para>
We start by getting all the users of the second element being inserted into the list:
<r:code>
au3 = lapply(getAllUsers(k[[3]]), function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %32 = bitcast %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17 to i8*"

[[1]][[2]]
[1] "  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %32) #13"

[[1]][[3]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %32) #13"

[[1]][[4]]
[1] "  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %32) #13"


[[2]]
[[2]][[1]]
[1] "  %36 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17, i64 0, i32 0"

[[2]][[2]]
[1] "  store %\"class.std::__1::basic_string.50\"* %name.i.i.i81, %\"class.std::__1::basic_string.50\"** %36, align 8"


[[3]]
[[3]][[1]]
[1] "  %37 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17, i64 0, i32 1"

[[3]][[2]]
[1] "  store %\"class.Rcpp::Vector.46\"* %orig, %\"class.Rcpp::Vector.46\"** %37, align 8"


[[4]]
[[4]][[1]]
[1] "  invoke void @_ZN4Rcpp6VectorILi19ENS_15PreserveStorageEE16create__dispatchINS_6traits12named_objectINS0_ILi14ES1_EEEES7_EES2_NS4_17integral_constantIbLb1EEERKT_RKT0_(%\"class.Rcpp::Vector.3.43\"* sret(%\"class.Rcpp::Vector.3.43\") align 8 %agg.result, %\"class.Rcpp::traits::named_object.49\"* nonnull align 8 dereferenceable(16) %ref.tmp, %\"class.Rcpp::traits::named_object.49\"* nonnull align 8 dereferenceable(16) %ref.tmp17)\n          to label %invoke.cont27 unwind label %lpad24"

]]></r:output>
</r:code>  
We see a similar pattern to the uses of the first element of the list.
We are interested in the second set of uses as this sets the first element of the named_object.
The first set of uses is bookkeeping, the third sets the <r:pkg>Rcpp</r:pkg>/<r/> object field and the fourth
is the creation  the list that we didn't omit.
</para>

<para>
  In the second set of uses, the first instruction is the GEP for the name field (more specifically one level further?).
  The second instruction sets that to %name.i.i.i81, so we follow this.
<r:code>
  au3[[2]][[2]][[1]]
<r:output><![CDATA[
[1] "  %name.i.i.i81 = getelementptr inbounds %\"class.Rcpp::Argument.56\", %\"class.Rcpp::Argument.56\"* %ref.tmp18, i64 0, i32 0"
]]></r:output>  
</r:code>  
Again, we see this relates to an <c:type>Rcpp::Argument</c:type>.
We get all uses of this
<r:code>
z = getAllUsers(au3[[2]][[2]][[1]])
<r:output><
![CDATA[
[[1]]
[1] "  invoke void @_ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_(%\"class.std::__1::basic_string.50\"* nonnull dereferenceable(24) %name.i.i.i81, %\"class.std::__1::basic_string.50\"* nonnull align 8 dereferenceable(24) %ref.tmp19)\n          to label %invoke.cont25 unwind label %lpad22"

[[2]]
[1] "  store %\"class.std::__1::basic_string.50\"* %name.i.i.i81, %\"class.std::__1::basic_string.50\"** %36, align 8"
]]></r:output>  
</r:code>
As we follow these chains, we get
<r:code>
getAllUsers(getAllUsers(getAllUsers(getAllUsers(z[[1]][[2]])[[2]])[[1]])[[1]])
<r:output><![CDATA[
[[1]]
[1] "  store i64 7809644627822735983, i64* %35, align 1"
]]></r:output>
</r:code>
</para>

<para>
  There appears to be something special about the word original.
  If we replace it with duncan, xyz, or riginal, we get literal values in the <ir/> code for these.
  If we replace it with Original (capital O), we don't get a literal value.
  If we change it priginal, we don't get a literal value.
</para>

</li>

<li>
<b>Finding the <r/> value and type of the second element of the list.</b>
The <r/> object for the second element of the list is relatively easy to determine using the same
initial approach we took for the first element of the list above.
<para>
We are interested in finding how this object is populated, specifically its first field
which holds the name of the object.
<r:code>
a3 = getAllUsers(k[[3]])
lapply(a3, function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
...
[[3]]
[[3]][[1]]
[1] "  %37 = getelementptr inbounds %\"class.Rcpp::traits::named_object.49\", %\"class.Rcpp::traits::named_object.49\"* %ref.tmp17, i64 0, i32 1"

[[3]][[2]]
[1] "  store %\"class.Rcpp::Vector.46\"* %orig, %\"class.Rcpp::Vector.46\"** %37, align 8"

...
]]></r:output>
</r:code>
Again we see accessing the second field of the <c:type>Rcpp::Vector</c:type> (via a GEP) and then setting its value.
The value is the first element of the second instruction shown, specifically %orig.
And this is the second parameter to the routine, i.e., the input parameter that follows the artificial first parameter
created to marshal the return value.
<r:code>
identical(lapply(a3, function(x) c(x, getAllUsers(x)))[[3]][[2]][[1]], p[[2]])
<r:output><![CDATA[
[1] TRUE
]]></r:output>
</r:code>
So we know that the second element of the list is a <c:type>NumericVector</c:type>, and that it is actually
the original input value. Since that was marked as const, we know it didn't change.
(Do we know that it and it contents didn't change, including any element of the underlying <r/> vector, and the const
doesn't just apply to the <r:pkg>Rcpp</r:pkg> fields?)
</li>
</ol>
</para>






<para>
This example comes from <r:pkg>rcppexamples</r:pkg> and the file
<file>NumericVectorExample.cpp</file>
We generate the <ir/> for this code, using level 2 optimization:
<sh:code>
clang -S -emit-llvm -fno-discard-value-names NumericVectorExample.cpp -o NumericVectorExampleO2.ir  -I`R RHOME`/include -O2 `Rscript -e "Rcpp:::CxxFlags()"`  
</sh:code>
We read the <ir/> into <r/>
<r:code>
m2 = parseIR("src/rcppexamples/NumericVectorExampleO2.ir")
</r:code>
There are 106 elements in the module. We only care about the one we can invoke from <r/>.
The names are mangled. We know the name is NumericVectorExample so we can find it with
<r:code>
grep("NumericVectorExample", names(m2), value = TRUE)
<r:output><![CDATA[
[1] "_Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE"
[2] "_GLOBAL__sub_I_NumericVectorExample.cpp"                             
]]></r:output>
</r:code>
The demangled names are
<r:code>
demangle(grep("NumericVectorExample", names(m2), value = TRUE))
<r:output><![CDATA[
[1] "NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)"
[2] "_GLOBAL__sub_I_NumericVectorExample.cpp"                             
]]></r:output>
</r:code>
</para>


<para>
  In fact, we want to look at RcppExports.cpp first as this is the file that contain the <r/>-accessible routines
  generated by <r:pkg>Rcpp</r:pkg>.
<r:code>
m3 = parseIR("rcppexamples/src/RcppExports02.ir")
</r:code>
Again, this has many routines <emdash/> 107 defined in the module and others that are referenced.
<r:code>
defs = getDefinedRoutines(m3)
w = (defs == demangle(defs))
defs[w]
<r:output><![CDATA[
[1] "_RcppExamples_DataFrameExample"    
[2] "__clang_call_terminate"            
[3] "_RcppExamples_DateExample"         
[4] "_RcppExamples_ListExamples"        
[5] "_RcppExamples_MatrixExample"       
[6] "_RcppExamples_NumericVectorExample"
[7] "_RcppExamples_RcppRNGs"            
[8] "_RcppExamples_StringVectorExample" 
[9] "R_init_RcppExamples"               
]]></r:output>
</r:code>
So the routines with names starting with <literal>_RcppExamples</literal>
are the ones of interest.
We look at <r:expr eval="false">m3$"_RcppExamples_NumericVectorExample"</r:expr>
<r:output><![CDATA[
%struct.SEXPREC.124* _RcppExamples_NumericVectorExample ( %struct.SEXPREC.124* origSEXP )
]]></r:output>
So this takes a single <c:type>SEXP</c:type> value and returns a <c:type>SEXP</c:type> value.
</para>

<para>
This simple wrapper routine has 86 blocks:
<r:code>
r = m3$"_RcppExamples_NumericVectorExample"
length(getBlocks(r))
</r:code>
We can see the routines it calls with
<r:code>
unique(getCalledRoutines(r))
<r:output><![CDATA[
 [1] "__cxa_guard_acquire"                                                                                                                             
 [2] "Rf_install"                                                                                                                                      
 [3] "__cxa_guard_release"                                                                                                                             
 [4] "llvm.lifetime.start.p0i8"                                                                                                                        
 [5] "R_GetCCallable"                                                                                                                                  
 [6] "__cxa_guard_abort"                                                                                                                               
 [7] NA                                                                                                                                                
 [8] "Rcpp::Vector<14, Rcpp::PreserveStorage> Rcpp::internal::as<Rcpp::Vector<14, Rcpp::PreserveStorage> >(SEXPREC*, Rcpp::traits::r_type_generic_tag)"
 [9] "NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)"                                                                            
[10] "Rcpp::RObject_Impl<Rcpp::PreserveStorage>& Rcpp::RObject_Impl<Rcpp::PreserveStorage>::operator=<SEXPREC*>(SEXPREC* const&)"                      
[11] "R_ReleaseObject"                                                                                                                                 
[12] "__clang_call_terminate"                                                                                                                          
[13] "llvm.lifetime.end.p0i8"                                                                                                                          
[14] "llvm.eh.typeid.for"                                                                                                                              
[15] "__cxa_begin_catch"                                                                                                                               
[16] "__cxa_end_catch"                                                                                                                                 
[17] "Rf_onintr"                                                                                                                                       
[18] "Rcpp::exception::copy_stack_trace_to_r() const"                                                                                                  
[19] "SEXPREC* exception_to_condition_template<Rcpp::exception>(Rcpp::exception const&, bool)"                                                         
[20] "Rf_protect"                                                                                                                                      
[21] "SEXPREC* exception_to_condition_template<std::exception>(std::exception const&, bool)"                                                           
[22] "operator new(unsigned long)"                                                                                                                     
[23] "string_to_try_error(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)"                               
[24] "operator delete(void*)"                                                                                                                          
[25] "Rf_lang2"                                                                                                                                        
[26] "Rf_eval"                                                                                                                                         
[27] "Rf_inherits"                                                                                                                                     
[28] "TYPEOF"                                                                                                                                          
[29] "Rf_length"                                                                                                                                       
[30] "VECTOR_ELT"                                                                                                                                      
[31] "R_ContinueUnwind"                                                                                                                                
[32] "Rf_unprotect"                                                                                                                                    
]]></r:output>
</r:code>


</para>




<para>
Once we know we are calling the <c:func>NumericVectorExample</c:func>, we find it in the <ir/> code created from
<file>NumericVectorExample.cpp</file>.
<r:code>
m2 = parseIR("rcppexamples/src/NumericVectorExample02.ir")
r = getDefinedRoutines(m2, names = FALSE)
demangle(names(r))
f = r[[ grep("NumericVectorExample", names(r)) ]]
<r:output><![CDATA[
void _Z20NumericVectorExampleRKN4Rcpp6VectorILi14ENS_15PreserveStorageEEE ( %"class.Rcpp::Vector.3.266"* agg.result, %"class.Rcpp::Vector.269"* orig )
]]></r:output>
</r:code>
We can query the parameters and explore their types:
<r:code>
p =  getParameters(f)
a = p[[2]]
getType(a)
ty = getElementType(getType(a))
</r:code>
</para>

<para>
Curiously, if we get the names of the defined routines and demangle them, we get
<r:code>
demangle(getName(f))  
# or
demangle(getDefinedRoutines(m2))[[3]]
<r:output><![CDATA[
[3] "NumericVectorExample(Rcpp::Vector<14, Rcpp::PreserveStorage> const&)"                                                                                                                                    ]]></r:output>
</r:code>
This shows the routine as having a single parameter, not two.
The first parameter in the actual <c:type>Function</c:type> object is used for returning the value of the routine.
</para>
<para>
Importantly, from this demangled name, we see the type of the input parameter (the second.)
It is <literal><![CDATA[Rcpp::Vector<14, Rcpp::PreserveStorage>]]></literal>.
The 14 is the <c:type>SEXPTYPE</c:type> and this corresponds to <c:define>REALSXP</c:define>.
This tells us the expected input type is a numeric vector.
We also see the object is constant, i.e., its contents are not changed.
</para>


<section>
<title>Additional Information from Parsing the <cpp/> Code</title>
<para>
<r:code>
library(RCIndex)
tu = createTU("~/GitWorkingArea/NativeCodeAnalysis/tests/rcppexamples/src/NumericVectorExample.cpp", gsub("^-I", "", capture.output(Rcpp:::CxxFlags())))
rc = getRoutines(tu)
</r:code>
<r:code>
nv = rc[["NumericVectorExample"]]
<r:output><![CDATA[
[1] "Rcpp::List NumericVectorExample(const NumericVector & orig)"
]]></r:output>
</r:code>

<r:code>
ty = getType(nv@params[[1]])
getName(ty)
<r:output><![CDATA[
[1] "const Rcpp::NumericVector &"
]]></r:output>
</r:code>
</para>
</section>


<section>
<title>Return Type</title>

<para>
  Using <llvm/>, the return type of the <c:func>NumericVectorExample</c:func> routine is
  <c:type>void</c:type>.
  The return value is set in the first argument and marshalled back to the caller via that.
  So we find where this first argument is used in the body of the routine
<r:code>
u = getAllUsers(p[[1]])
</r:code>
There is only one use of this argument in the NumericVectorExample routine.
This is an <r:class>InvokeInst</r:class> instruction. The routine that is called is
<r:code>
fun = getCalledFunction(u[[1]])
</r:code>
<ignore>
<note>We should be able to call getName(fun) to get the name and then demangle this. But we don't have a getName method
for a Function. (Added now.)
However, we can get the name with
<r:code><![CDATA[
i = which(sapply(getDefinedRoutines(as(fun, "Module"), names = FALSE), identical, u))
demangle(getDefinedRoutines(as(fun, "Module"))[i])
[1] "Rcpp::Vector<19, Rcpp::PreserveStorage> Rcpp::Vector<19, Rcpp::PreserveStorage>::create__dispatch<Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> >, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > >(Rcpp::traits::integral_constant<bool, true>, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&, Rcpp::traits::named_object<Rcpp::Vector<14, Rcpp::PreserveStorage> > const&)"
]]></r:code>
</note>
</ignore>
</para>
</section>


<section>
<title>DateExample</title>

<para>
We look at the DateExample  :
<r:code>
mm = parseIR("rcppexamples/src/DateExample.ir")
r = getDefinedRoutines(mm, names = FALSE)
i = grep("DateExample", names(r))
f = r[[i]]
demangle(getName(f))
<r:output><![CDATA[
[1] "DateExample(Rcpp::newDateVector&, Rcpp::newDatetimeVector&)"
]]></r:output>
</r:code>
So we know the R types of the two parameters of DateExample.
</para>


<para>
Looking at the wrapper routines:  
<r:code>
m3 = parseIR("rcppexamples/src/RcppExports02.ir")
i = names(m3)[ grep("^_RcppExamples_", names(m3)) ] 
fun = m3[[ i[2] ]]
demangle(unique(getCalledFunctions(m3[[ i[2] ]])))
</r:code>
So we see the call to DateExample and also calls to <c:func><![CDATA[Rcpp:internal::as<> ]]></c:func> to create the
<c:type>Rcpp::newDateVector</c:type> and <c:type>Rcpp::newDatetimeVector</c:type> objects.
</para>



</section>


<section>
<title>Non-List Return Types</title>

<para>
<r:code>
eg  = parseIR("RcppEgO2.ir")
i = grep("row_max", names(eg), value = TRUE)
fun = eg[[i]]
demangle(getName(fun))
</r:code>
So we have the type of the sole parameter - a numeric Matrix.
</para>

<para>
The return value is again marshaled via a compiler-created first parameter.
We can find out where it is used in the routine:
<r:code>
u1 = getAllUsers(getParameters(fun)[[1]])
<r:output><![CDATA[
[[1]]
[1] "  %9 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0, i32 0"

[[2]]
[1] "  %11 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 1, i32 0"

[[3]]
[1] "  %15 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0"
]]></r:output>
</r:code>
These are GEP to access the first and second elements of the Rcpp::Vector object.
These may be used to read the value or to set the value.
We can follow these to see where they are used:
<r:code>
u2 = lapply(u1, function(x) c(x, getAllUsers(x)))
<r:output><![CDATA[
[[1]]
[[1]][[1]]
[1] "  %9 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0, i32 0"

[[1]][[2]]
[1] "  store %struct.SEXPREC.386* %10, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[3]]
[1] "  %17 = load %struct.SEXPREC.386*, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[4]]
[1] "  %33 = load %struct.SEXPREC.386*, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[5]]
[1] "  store %struct.SEXPREC.386* %43, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[6]]
[1] "  %78 = load %struct.SEXPREC.386*, %struct.SEXPREC.386** %9, align 8, !tbaa !10"

[[1]][[7]]
[1] "  store %struct.SEXPREC.386* %88, %struct.SEXPREC.386** %9, align 8, !tbaa !10"


[[2]]
[[2]][[1]]
[1] "  %11 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 1, i32 0"

[[2]][[2]]
[1] "  store double* null, double** %11, align 8, !tbaa !12"

[[2]][[3]]
[1] "  %68 = load double*, double** %11, align 8, !tbaa !12"


[[3]]
[[3]][[1]]
[1] "  %15 = getelementptr inbounds %\"class.Rcpp::Vector.396\", %\"class.Rcpp::Vector.396\"* %0, i64 0, i32 0"

[[3]][[2]]
[1] "  invoke void @_ZN4Rcpp15PreserveStorageINS_6VectorILi14ES0_EEE5set__EP7SEXPREC(%\"class.Rcpp::PreserveStorage.397\"* nonnull dereferenceable(8) %15, %struct.SEXPREC.386* %13)\n          to label %16 unwind label %31"
]]></r:output>
</r:code>
</para>

<para>
It is not obvious we should look at the third of these, but this accesses the first field which is the PreserveStorage
field of the Rcpp::Vector and then passes this to the routine
<r:code>
demangle(getName(getCalledFunction(u2[[3]][[2]])))
<r:output><![CDATA[
[1] "Rcpp::PreserveStorage<Rcpp::Vector<14, Rcpp::PreserveStorage> >::set__(SEXPREC*)"
]]></r:output>
</r:code>
This templated routine indicates that the <r/> object is a numeric vector.
The second arugment in this call to set__ is
<r:code>
u2[[3]][[2]][[2]]
<r:output><![CDATA[
[1] "  %13 = invoke %struct.SEXPREC.386* @Rf_allocVector(i32 14, i64 %12)\n          to label %14 unwind label %31"
]]></r:output>
</r:code>
and this is the value being set.
So we know that the return value's PreserveStorage field is being set to a numeric vector.
</para>
<para>
We can follow the second argument in the call to <c:func>Rf_allocVector</c:func> to
attempt to identify the length of the vector.
<r:code>
u2[[3]][[2]][[2]][[2]][[1]][[1]]
<r:output><![CDATA[
[1] "  %7 = getelementptr inbounds %\"class.Rcpp::Matrix.399\", %\"class.Rcpp::Matrix.399\"* %1, i64 0, i32 1"
]]></r:output>
</r:code>
And if we look at the type of the Rcpp::Matrix
<r:code>
getFields(getElementType(getType(u2[[3]][[2]][[2]][[2]][[1]][[1]][[1]])))
<r:output><![CDATA[
[[1]]
Type StructTyID 

[[2]]
Type IntegerTyID 

[[3]]
Type ArrayTyID 

]]></r:output>  
</r:code>
This second element (indexed as position 1 in the GEP) appears to be the number of rows in the matrix, and indeed is
when we look at Rcpp/vector/Matrix.h.
</para>




</section>




<section>
<title>Parsing the Template Parameter Types</title>

<para>
  We can write the routine signature to a file, preceded by an inclusion of Rcpp.h
  and adding the void return type for the routine.
Then we can use <r:pkg>RCIndex</r:pkg> to parse the <cpp/> code:
<r:code>
e = createTU("/tmp/foo.cc", "/Users/duncan/Rpackages4/Rcpp/include")
r = getRoutines(e)
</r:code>
For some reason, the parameter is a ParamDecl but does not have content.
</para>
</section>






</section>
